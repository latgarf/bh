#!/usr/bin/env python3

# import os
import sqlite3
import datetime, time
import argparse

from bitcoind_commands import getreceivedbyaddress

from bhsdk import config
from bhsdk.constants import PRECISION
from bhsdk.utils import float_equal_0
from bhsdk.enums import TransactionStatus as TS
from bhsdk.time import now_epoch, now_epoch_str

MINCONF = config.get('bitcoind_params', 'minconf')
conn = sqlite3.connect(config.get('sqlite3', 'db_file'))

# query db for address list
def get_address_dict():
    """ return dict with key uid, value (address, amount). """
    c = conn.cursor()
    table = config.get('sqlite3', 'submitted_table')
    col = config.get('sqlite3', 'addr_our_col')
    query = ("SELECT order_id, %s, amount_ordered, fee_quoted "
             " FROM %s WHERE status=%d") % (col, table, TS.WAIT_FOR_PAYMENT)
    ret = {}
    for a in c.execute(query):
        ret[a[0]] = (a[1], a[2], a[3])
    return ret

def add_new_order(uid, payment, amount):
    """ Open a new order. """

    query = ("UPDATE opened SET time_opened='%s',"
             "payment_received=%f, "
             "amount_opened=%f, "
             "status=%d "
             " where order_id='%s'") % (now_epoch_str(), payment, amount, TS.OPEN, uid)
    # conn = sqlite3.connect(config.get('sqlite3', 'db_file'))
    c = conn.cursor()
    print(query)
    c.execute(query)

    update_status_query = 'UPDATE %s set status = %d where order_id=\'%s\'' % (config.get('sqlite3', 'submitted_table'), TS.OPEN, uid)
    c.execute(update_status_query)
    conn.commit()

    return True

# processes new orders
def process_new_orders(new_order_dict, dry_run):
    for uid in new_order_dict.keys():
        received = new_order_dict[uid][0]
        amount   = new_order_dict[uid][1]
        fee      = new_order_dict[uid][2]

        amount = float(amount) * float(received) / float(fee)

        if dry_run:
            print('uid %s, %s received, %f amount opened, status %s' %(uid, received, amount, status))
            continue
        if not add_new_order(uid, received, amount):
            # TODO: logging warning
            print('ERROR: open new order %s with payment %f and amount %f failed' % (uid, received, amount_opened))

def check_payments(dry_run):

    uid_addr_dict = get_address_dict()
    new_order_dict = {}
    for uid in uid_addr_dict.keys():
        addr   = uid_addr_dict[uid][0]
        amount = uid_addr_dict[uid][1]
        fee    = uid_addr_dict[uid][2]

        a = getreceivedbyaddress(addr, MINCONF)
        if float_equal_0(a):
            continue

        new_order_dict[uid] = (a, amount, fee, status)

    if dry_run:
        print('About to process %d new orders' % len(new_order_dict))

    if len(new_order_dict) > 0:
        process_new_orders(new_order_dict, dry_run)


def check_expiry():
    exp_seconds = int(config.get('orders', 'order_exp_seconds'))
    threshold = now_epoch() - exp_seconds
    table = config.get('sqlite3', 'submitted_table')

    query = ("UPDATE %s "
             "SET status=%d "
             "WHERE time_ordered<'%d'") % (table, TS.CANCELLED, threshold)
    c = conn.cursor()
    c.execute(query)
    conn.commit()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--dry', action='store_true')
    args = parser.parse_args()

    check_expiry()
    check_payments(args.dry)


if __name__ == "__main__":
    main()
